require 'spec_helper'
require 'num4regana'

RSpec.describe Num4RegAnaLib do
    describe Num4RegAnaLib::LogitBayesRegAnaLib do
        let!(:regana) { Num4RegAnaLib::LogitBayesRegAnaLib.new }
        it '#non_line_reg_ana' do
            yi = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            xij = [
                [1, 24],
                [1, 18],
                [0, 15],
                [1, 16],
                [0, 10],
                [1, 26],
                [1, 2],
                [0, 24],
                [1, 18],
                [1, 22],
                [1, 3],
                [1, 6],
                [0, 15],
                [0, 12],
                [1, 6],
                [0, 6],
                [1, 12],
                [0, 12],
                [1, 18],
                [1, 3],
                [1, 8],
                [0, 9],
                [0, 12],
                [0, 6],
                [0, 8],
                [1, 12],
            ]
            res = {
                "intercept":  0.4804,    # 定数項
                "slope":      [0.5669, 0.5422],     # 回帰係数
            }
            regana.non_line_reg_ana(yi, xij)
#            expect(
#                regana.non_line_reg_ana(yi, xij)
#            ).to linereg(res, 4)
# {:intercept=>0.5742886218005325, :slope=>[0.5517212822536828, 0.5748054561700319]}
# {:intercept=>0.44426881466394974, :slope=>[0.5202123495676625, 0.5477244196524941]}
# {:intercept=>0.4217903552231481, :slope=>[0.44186307024347676, 0.4862701919881903]}
# {:intercept=>0.5262942475829124, :slope=>[0.49921928685191447, 0.5706646737771902]}
# {:intercept=>0.3884244613773042, :slope=>[0.5056642913972654, 0.4745384336414456]}
# {:intercept=>0.5351828454958808, :slope=>[0.5056896501675783, 0.4791052156842009]}
# {:intercept=>0.4602120983665574, :slope=>[0.5055956983031135, 0.4708857603763919]}
# {:intercept=>0.497025613696512, :slope=>[0.36487326390043245, 0.492896678210392]}
# {:intercept=>0.5531287937984478, :slope=>[0.5259886471410888, 0.5435106585278309]}
# {:intercept=>0.5464450003625718, :slope=>[0.43660420511681824, 0.5720351560631274]}
# {:intercept=>0.5276046180786333, :slope=>[0.5559282632987986, 0.468820807304124]}
# {:intercept=>0.48784739570656227, :slope=>[0.4568823063251655, 0.5098863627032081]}
# {:intercept=>0.5042501962712989, :slope=>[0.5332548374012213, 0.4914658804323339]}
        end
        it '#get_bic' do
            reg = {
                :intercept=>  -6.2313,    # 定数項
                :slope=>      [2.5995, 0.1652],     # 回帰係数
            }
            xij = [
                [1, 24],
                [1, 18],
                [0, 15],
                [1, 16],
                [0, 10],
                [1, 26],
                [1, 2],
                [0, 24],
                [1, 18],
                [1, 22],
                [1, 3],
                [1, 6],
                [0, 15],
                [0, 12],
                [1, 6],
                [0, 6],
                [1, 12],
                [0, 12],
                [1, 18],
                [1, 3],
                [1, 8],
                [0, 9],
                [0, 12],
                [0, 6],
                [0, 8],
                [1, 12],
            ]
            expect(
                regana.get_bic(reg, xij)
            ).to my_round(159.386, 3)
        end
    end    
    describe Num4RegAnaLib::PoissonBayesRegAnaLib do
        let!(:regana) { Num4RegAnaLib::PoissonBayesRegAnaLib.new }
        it '#non_line_reg_ana' do
            yi = [4, 10, 7, 14]
            xij = [
                [1],
                [2],
                [3],
                [4],
            ]
            res = {
                "intercept":  1.3138,    # 定数項
                "slope":      [0.3173],  # 回帰係数
            }
            regana.non_line_reg_ana(yi, xij)
#            expect(
#                regana.non_line_reg_ana(yi, xij)
#            ).to linereg(res, 4)
# {:intercept=>0.4341885635221602, :slope=>[0.5703137378188881]}
# {:intercept=>0.5233791563571913, :slope=>[0.4629854978645746]}
# {:intercept=>0.5367747588576945, :slope=>[0.5375546954530761]}
# {:intercept=>0.47904156491260963, :slope=>[0.5388200495317951]}
# {:intercept=>0.46203388124304673, :slope=>[0.5397092479737418]}
# {:intercept=>0.5257152478576502, :slope=>[0.4886719357890477]}
# {:intercept=>0.5804080930641892, :slope=>[0.44900040875709746]}
# {:intercept=>0.4507388046104568, :slope=>[0.48745918802045546]}
# {:intercept=>0.49936214196283957, :slope=>[0.3912596201726442]}
# {:intercept=>0.5487982455283444, :slope=>[0.5147860287730678]}
# {:intercept=>0.4725875532769969, :slope=>[0.4845174804974889]}
# {:intercept=>0.4970204844359125, :slope=>[0.567928451719875]}
# {:intercept=>0.4259367867841381, :slope=>[0.48150509901479754]}
# {:intercept=>0.5276834415079702, :slope=>[0.47548967412772514]}
        end
        it '#get_bic' do
            reg = {
                :intercept => 0.504607,    # 定数項
                :slope    =>  [0.594661],  # 回帰係数
            }
            xij = [
                [1],
                [2],
                [3],
                [4],
            ]
            expect(
                regana.get_bic(reg, xij)
            ).to my_round(-13.157, 3)
        end
    end
end

